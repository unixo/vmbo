<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>vmbo - Virtual Memory BO: Riferimenti per il file vmbo/src/io_device.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generato da Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Pagina&nbsp;Principale</span></a></li>
      <li><a href="modules.html"><span>Moduli</span></a></li>
      <li><a href="annotated.html"><span>Strutture&nbsp;dati</span></a></li>
      <li class="current"><a href="files.html"><span>File</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>Elenco&nbsp;dei&nbsp;file</span></a></li>
      <li><a href="globals.html"><span>Elementi&nbsp;globali</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Riferimenti per il file vmbo/src/io_device.c</h1><code>#include &quot;<a class="el" href="a00032.html">io_device.h</a>&quot;</code><br>

<p>
<a href="a00030.html">Vai al codice sorgente di questo file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Strutture dati</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">io_requests</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lista FIFO di richieste di I/O.  <a href="a00007.html#_details">Continua...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Funzioni</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#28b5ceb23d706ad5bb7b3cb39b465ca0">thread_io_device</a> (void *parg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread dispositivo I/O.  <a href="#28b5ceb23d706ad5bb7b3cb39b465ca0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pthread_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html#g0de75477baa4d452a538a517c6589ca0">io_device_init</a> (int min, int max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inizializzazione I/O.  <a href="a00027.html#g0de75477baa4d452a538a517c6589ca0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html#g64fbfccf96403a1ccbdc4f4408f8adf5">io_device_read</a> (<a class="el" href="a00024.html#c531592bdbc7dfba81524d5eb21f9778">uint16_t</a> procnum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Richiede un accesso al dispositivo di I/O.  <a href="a00027.html#g64fbfccf96403a1ccbdc4f4408f8adf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html#gbc58cac7b3c0bd4162719dd9f846a6ae">tell_io_device_to_exit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determina l'uscita del thread di I/O.  <a href="a00027.html#gbc58cac7b3c0bd4162719dd9f846a6ae"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variabili</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static struct <a class="el" href="a00007.html">io_requests</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#0ae99440354d7bc7c7f71ee3b8a24e6b">io_request_head</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puntatore al primo elemento della FIFO.  <a href="#0ae99440354d7bc7c7f71ee3b8a24e6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="a00024.html#c531592bdbc7dfba81524d5eb21f9778">uint16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#6601088e2e79ba5976852f8c288abc7b">ioreq_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Numero di richieste di I/O in coda.  <a href="#6601088e2e79ba5976852f8c288abc7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#c091f4fd4ff5e722cae1a2d5191812ab">fifo_lock</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex posto a protezione della FIFO.  <a href="#c091f4fd4ff5e722cae1a2d5191812ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static pthread_cond_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#31283d7eee29d1bafe25eb2d4da02c2d">wait_cond</a> = PTHREAD_COND_INITIALIZER</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Condizione d'attesa nel quale il thread thread_io_device si blocca in attesa che la FIFO contenga un elemento.  <a href="#31283d7eee29d1bafe25eb2d4da02c2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af7d27c258f7a7b938ac24ff5d8a07ba">wait_lock</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex posto a protezione della condizione wait_cond.  <a href="#af7d27c258f7a7b938ac24ff5d8a07ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#84e057837f9f59a7f0dc11bd32366b76">request_lock</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex posto a protezione della FIFO: per inserire/rimuovere elementi dalla coda si deve prima effettuare il lock di questo mutex.  <a href="#84e057837f9f59a7f0dc11bd32366b76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#c8473ece3559c12335d393685b9d9d0d">io_device_should_exit</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Durata del thread I/O.  <a href="#c8473ece3559c12335d393685b9d9d0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00012.html">proc_t</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#9399ea5dcc68d7ce40f84bf37593a936">proc_table</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vettore dei processi attivi.  <a href="#9399ea5dcc68d7ce40f84bf37593a936"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#710037465055a75cba7d3b2625f966f8">max_proc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Numero di processi concorrenti.  <a href="#710037465055a75cba7d3b2625f966f8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Descrizione dettagliata</h2>
<dl class="author" compact><dt><b>Autore:</b></dt><dd>Ferruccio Vitale (<a href="mailto:unixo@devzero.it">unixo@devzero.it</a>) </dd></dl>
<dl class="date" compact><dt><b>Data:</b></dt><dd>21/04/2009</dd></dl>
<dl class="note" compact><dt><b>Nota:</b></dt><dd>Universita' degli studi di Urbino "Carlo Bo"<br>
 Sistemi Operativi<br>
 Professore Emanuele Lattanzi<br>
 Anno Accademico 2008 - 2009 </dd></dl>

<p>Definizione nel file <a class="el" href="a00030.html">io_device.c</a>.</p>
<hr><h2>Documentazione delle funzioni</h2>
<a class="anchor" name="28b5ceb23d706ad5bb7b3cb39b465ca0"></a><!-- doxytag: member="io_device.c::thread_io_device" ref="28b5ceb23d706ad5bb7b3cb39b465ca0" args="(void *parg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * thread_io_device           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>parg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thread dispositivo I/O. 
<p>
La funzione costituisce il corpo del thread che rappresenta il dispositivo di I/O. Il suddetto thread sospende la propria esecuzione fintanto che non siano presenti delle richieste d'accesso al dispositivo. Il thread termina la propria esecuzione quando sono stati compiuti il numero massimo d'accessi alla memoria (ad opera dell'MMU). <dl compact><dt><b>Parametri:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parg</em>&nbsp;</td><td>inutilizzato </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Restituisce:</b></dt><dd>inutilizzato </dd></dl>

<p>Definizione alla linea <a class="el" href="a00030.html#l00069">69</a> del file <a class="el" href="a00030.html">io_device.c</a>.</p>

<p>
<div class="dynheader">
Questo è il grafo delle chiamate per questa funzione:</div>
<div class="dynsection">
<p><center><img src="a00015_28b5ceb23d706ad5bb7b3cb39b465ca0_cgraph.png" border="0" usemap="#a00015_28b5ceb23d706ad5bb7b3cb39b465ca0_cgraph_map" alt=""></center>
<map name="a00015_28b5ceb23d706ad5bb7b3cb39b465ca0_cgraph_map">
<area shape="rect" id="node3" href="a00022.html#484d2e162b90ad46d32d1906577ab09a" title="La funzione restituisce un numero intero casuale nell&#39;intervallo compreso tra..." alt="" coords="189,5,304,35"></map>
</div>

<p>
<div class="dynheader">
Questo è il grafo dei chiamanti di questa funzione:</div>
<div class="dynsection">
<p><center><img src="a00015_28b5ceb23d706ad5bb7b3cb39b465ca0_icgraph.png" border="0" usemap="#a00015_28b5ceb23d706ad5bb7b3cb39b465ca0_icgraph_map" alt=""></center>
<map name="a00015_28b5ceb23d706ad5bb7b3cb39b465ca0_icgraph_map">
<area shape="rect" id="node3" href="a00027.html#g0de75477baa4d452a538a517c6589ca0" title="Inizializzazione I/O." alt="" coords="189,5,301,35"><area shape="rect" id="node5" href="a00025.html#3c04138a5bfe5d72780bb7e82a18e627" title="main" alt="" coords="349,5,403,35"></map>
</div>

</div>
</div><p>
<hr><h2>Documentazione delle variabili</h2>
<a class="anchor" name="c091f4fd4ff5e722cae1a2d5191812ab"></a><!-- doxytag: member="io_device.c::fifo_lock" ref="c091f4fd4ff5e722cae1a2d5191812ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="a00015.html#c091f4fd4ff5e722cae1a2d5191812ab">fifo_lock</a> = PTHREAD_MUTEX_INITIALIZER<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutex posto a protezione della FIFO. 
<p>

<p>Definizione alla linea <a class="el" href="a00030.html#l00030">30</a> del file <a class="el" href="a00030.html">io_device.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="c8473ece3559c12335d393685b9d9d0d"></a><!-- doxytag: member="io_device.c::io_device_should_exit" ref="c8473ece3559c12335d393685b9d9d0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00015.html#c8473ece3559c12335d393685b9d9d0d">io_device_should_exit</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Durata del thread I/O. 
<p>
Questa variabile determina, quando posto ad uno, l'uscita del thread che emula il dispositivo di I/O; tale condizione viene impostata dalla funzione memory_access quando viene raggiunto il limite massimo d'accessi alla memoria. 
<p>Definizione alla linea <a class="el" href="a00030.html#l00052">52</a> del file <a class="el" href="a00030.html">io_device.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="0ae99440354d7bc7c7f71ee3b8a24e6b"></a><!-- doxytag: member="io_device.c::io_request_head" ref="0ae99440354d7bc7c7f71ee3b8a24e6b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="a00007.html">io_requests</a> <a class="el" href="a00015.html#0ae99440354d7bc7c7f71ee3b8a24e6b">io_request_head</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Puntatore al primo elemento della FIFO. 
<p>

</div>
</div><p>
<a class="anchor" name="6601088e2e79ba5976852f8c288abc7b"></a><!-- doxytag: member="io_device.c::ioreq_count" ref="6601088e2e79ba5976852f8c288abc7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html#c531592bdbc7dfba81524d5eb21f9778">uint16_t</a> <a class="el" href="a00015.html#6601088e2e79ba5976852f8c288abc7b">ioreq_count</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Numero di richieste di I/O in coda. 
<p>

<p>Definizione alla linea <a class="el" href="a00030.html#l00026">26</a> del file <a class="el" href="a00030.html">io_device.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="710037465055a75cba7d3b2625f966f8"></a><!-- doxytag: member="io_device.c::max_proc" ref="710037465055a75cba7d3b2625f966f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00025.html#710037465055a75cba7d3b2625f966f8">max_proc</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Numero di processi concorrenti. 
<p>
La variabile <code>max_proc</code>, per default, viene inizializzato al valore 5, ma e tuttavia modificabile usando il paramentro <code>-p</code>. 
<p>Definizione alla linea <a class="el" href="a00035.html#l00102">102</a> del file <a class="el" href="a00035.html">proc.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="9399ea5dcc68d7ce40f84bf37593a936"></a><!-- doxytag: member="io_device.c::proc_table" ref="9399ea5dcc68d7ce40f84bf37593a936" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00012.html">proc_t</a> ** <a class="el" href="a00025.html#3ced92996544dd3229aeeb148a8b587e">proc_table</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vettore dei processi attivi. 
<p>
Viene allocato dalla funzione proc_init e deallocato nel main al termine dell'esecuzione; il numero massimo di elementi e dato dal valore di max_proc. 
<p>Definizione alla linea <a class="el" href="a00035.html#l00095">95</a> del file <a class="el" href="a00035.html">proc.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="84e057837f9f59a7f0dc11bd32366b76"></a><!-- doxytag: member="io_device.c::request_lock" ref="84e057837f9f59a7f0dc11bd32366b76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="a00015.html#84e057837f9f59a7f0dc11bd32366b76">request_lock</a> = PTHREAD_MUTEX_INITIALIZER<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutex posto a protezione della FIFO: per inserire/rimuovere elementi dalla coda si deve prima effettuare il lock di questo mutex. 
<p>

<p>Definizione alla linea <a class="el" href="a00030.html#l00044">44</a> del file <a class="el" href="a00030.html">io_device.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="31283d7eee29d1bafe25eb2d4da02c2d"></a><!-- doxytag: member="io_device.c::wait_cond" ref="31283d7eee29d1bafe25eb2d4da02c2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_cond_t <a class="el" href="a00015.html#31283d7eee29d1bafe25eb2d4da02c2d">wait_cond</a> = PTHREAD_COND_INITIALIZER<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Condizione d'attesa nel quale il thread thread_io_device si blocca in attesa che la FIFO contenga un elemento. 
<p>

<p>Definizione alla linea <a class="el" href="a00030.html#l00035">35</a> del file <a class="el" href="a00030.html">io_device.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="af7d27c258f7a7b938ac24ff5d8a07ba"></a><!-- doxytag: member="io_device.c::wait_lock" ref="af7d27c258f7a7b938ac24ff5d8a07ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="a00015.html#af7d27c258f7a7b938ac24ff5d8a07ba">wait_lock</a> = PTHREAD_MUTEX_INITIALIZER<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutex posto a protezione della condizione wait_cond. 
<p>

<p>Definizione alla linea <a class="el" href="a00030.html#l00039">39</a> del file <a class="el" href="a00030.html">io_device.c</a>.</p>

</div>
</div><p>
</div>
<table border="0" width="100%" style="border-top:1px solid black;">
	<tr><td align="center"><img src="logo_uniurbdotit.jpg"></td></tr>
	<tr><td align="center"><b>Università degli studi di Urbino "Carlo Bo"</b></td></tr>
</table>	
